<body bgcolor=black>
<center><canvas id='canvas1' width=800 height=800></canvas>

<script>

// A TINY MATRIX LIBRARy

let mInverse = m => {
   let dst = [], det = 0, cofactor = (c, r) => {
      let s = (i, j) => m[c+i & 3 | (r+j & 3) << 2];
      return (c+r & 1 ? -1 : 1) * ( (s(1,1) * (s(2,2) * s(3,3) - s(3,2) * s(2,3)))
                                  - (s(2,1) * (s(1,2) * s(3,3) - s(3,2) * s(1,3)))
                                  + (s(3,1) * (s(1,2) * s(2,3) - s(2,2) * s(1,3))) );
   }
   for (let n = 0 ; n < 16 ; n++) dst.push(cofactor(n >> 2, n & 3));
   for (let n = 0 ; n <  4 ; n++) det += m[n] * dst[n << 2]; 
   for (let n = 0 ; n < 16 ; n++) dst[n] /= det;
   return dst;
}
let matrixMultiply = (a, b) => {
   let dst = [];
   for (let n = 0 ; n < 16 ; n++)
      dst.push(a[n&3]*b[n&12] + a[n&3|4]*b[n&12|1] + a[n&3|8]*b[n&12|2] + a[n&3|12]*b[n&12|3]);
   return dst;
}
let C = t => Math.cos(t);
let S = t => Math.sin(t);
let mIdentity = () => [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];
let mPerspective = (fl, m) => matrixMultiply(m, [1,0,0,0, 0,1,0,0, 0,0,1,-1/fl, 0,0,0,1]);
let mRotateX = (t, m) => matrixMultiply(m, [1,0,0,0, 0,C(t),S(t),0, 0,-S(t),C(t),0, 0,0,0,1]);
let mRotateY = (t, m) => matrixMultiply(m, [C(t),0,-S(t),0, 0,1,0,0, S(t),0,C(t),0, 0,0,0,1]);
let mRotateZ = (t, m) => matrixMultiply(m, [C(t),S(t),0,0, -S(t),C(t),0,0, 0,0,1,0, 0,0,0,1]);
let mScale = (x,y,z, m) => matrixMultiply(m, [x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]);
let mTranslate = (x,y,z, m) => matrixMultiply(m, [1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]);

// INITIALIZE GL

let start_gl = (canvas, meshData, vertexSize, vertexShader, fragmentShader) => {
   let gl = canvas.getContext("webgl");
   let program = gl.createProgram();
   gl.program = program;
   let addshader = (type, src) => {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS))
         throw "Cannot compile shader:\n\n" + gl.getShaderInfoLog(shader);
      gl.attachShader(program, shader);
   };
   addshader(gl.VERTEX_SHADER  , vertexShader  );
   addshader(gl.FRAGMENT_SHADER, fragmentShader);
   gl.linkProgram(program);
   if (! gl.getProgramParameter(program, gl.LINK_STATUS))
      throw "Could not link the shader program!";
   gl.useProgram(program);
   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
   gl.enable(gl.DEPTH_TEST);
   gl.depthFunc(gl.LEQUAL);
   let vertexAttribute = (name, size, position) => {
      let attr = gl.getAttribLocation(program, name);
      gl.enableVertexAttribArray(attr);
      gl.vertexAttribPointer(attr, size, gl.FLOAT, false, vertexSize * 4, position * 4);
   }
   vertexAttribute('aPos', 3, 0);
   vertexAttribute('aNor', 3, 3);
   return gl;
}

//CREATE A TRIANGLE_STRIP MESH

let createMesh = (nu, nv, p) => {
   let mesh = [];
   for (let j = nv-1 ; j >= 0 ; j--) {
      for (let i = 0 ; i <= nu ; i++)
         mesh.push(p(i/nu,(j+1)/nv), p(i/nu,j/nv));
      mesh.push(p(1,j/nv), p(0,j/nv));
   }
   return mesh.flat();
}

// DEFINE VARIOUS KINDS OF TRIANGLE_STRIP MESHES

let sphere = (nu, nv) => createMesh(nu, nv, (u,v) => {
   let theta = 2 * Math.PI * u;
   let phi = Math.PI * (v - .5);
   let x = C(phi) * C(theta),
       y = C(phi) * S(theta),
       z = S(phi);
   return [ x,y,z, x,y,z ];
});

let tube = (nu, nv) => createMesh(nu, nv, (u,v) => {
   let x = C(2 * Math.PI * u),
       y = S(2 * Math.PI * u),
       z = 2 * v - 1;
   return [ x,y,z, x,y,0 ];
});

let disk = (nu, nv) => createMesh(nu, nv, (u,v) => {
   let x = v * C(2 * Math.PI * u),
       y = v * S(2 * Math.PI * u);
   return [ x,y,0, 0,0,1 ];
});

let cylinder = (nu, nv) => createMesh(nu, nv, (u,v) => {
   let x = C(2 * Math.PI * u),
       y = S(2 * Math.PI * u);
   switch (5 * v >> 0) {
   case 0: return [ 0,0,-1, 0,0,-1 ];
   case 1: return [ x,y,-1, 0,0,-1 ];
   case 2: return [ x,y,-1, x,y, 0 ];
   case 3: return [ x,y, 1, x,y, 0 ];
   case 4: return [ x,y, 1, 0,0, 1 ];
   case 5: return [ 0,0, 1, 0,0, 1 ];
   }
});

let torus = (nu, nv) => createMesh(nu, nv, (u,v) => {
   let ct = C(2 * Math.PI * u);
   let st = S(2 * Math.PI * u);
   let cp = C(2 * Math.PI * v);
   let sp = S(2 * Math.PI * v);
   let x = (1 + .5 * cp) * ct,
       y = (1 + .5 * cp) * st,
       z =      .5 * sp;
   return [ x,y,z, cp*ct,cp*st,sp ];
});

// SHORTCUT TO MAKE IT EASIER TO DEFINE CUBE AND OCTAHEDRON

let strToTris = str => {
   let tris = [];
   for (let n = 0 ; n < str.length ; n++)
      switch (str.charAt(n)) {
      case 'N': tris.push(-1    ); break;
      case 'n': tris.push(-0.577); break;
      case '0': tris.push( 0    ); break;
      case 'p': tris.push( 0.577); break;
      case 'P': tris.push( 1    ); break;
      }
   return tris;
}

// DEFINE SOME MESHES MADE FROM TRIANGLES

let cube = strToTris(`PNP00P PPP00P NPP00P  NPP00P NNP00P PNP00P
                      NPN00N PPN00N PNN00N  PNN00N NNN00N NPN00N
                      PPNP00 PPPP00 PNPP00  PNPP00 PNNP00 PPNP00
                      NNPN00 NPPN00 NPNN00  NPNN00 NNNN00 NNPN00
                      NPP0P0 PPP0P0 PPN0P0  PPN0P0 NPN0P0 NPP0P0
                      PNN0N0 PNP0N0 NNP0N0  NNP0N0 NNN0N0 PNN0N0`);

let octahedron = strToTris(`00Nnnn 0N0nnn N00nnn  P00pnn 0N0pnn 00Npnn
                            N00npn 0P0npn 00Nnpn  00Nppn 0P0ppn P00ppn
                            00Pnnp 0N0nnp N00nnp  00Ppnp 0N0pnp P00pnp
                            N00npp 0P0npp 00Pnpp  P00ppp 0P0ppp 00Pppp`);

let pyramid = strToTris(`00Nnnn 0N0nnn N00nnn  
                            N00npn 0P0npn 00Nnpn  
                            00Pnnp 0N0nnp N00nnp
                            N00npp 0P0npp 00Pnpp`);

let triangle = strToTris(`00Nnnn 0N0nnn N00nnn`);



let sharkParts = [
// body
{
   type: 1,
   color: [0.5, 0.5, 1.0], 
   mesh: new Float32Array(sphere(40, 20)),
   transform: (time, swimX, swimY, swimZ) =>
      mTranslate(swimX + 3.5, swimY, swimZ, mScale(0.45, 0.15, 1, mIdentity())) // Apply swimming motion
},
   // top fin
   {
      type: 0,
      color: [0.2, 0.2, 0.8], 
      mesh: new Float32Array(octahedron),
      transform: (time, swimX, swimY, swimZ) =>
         mTranslate(0, swimY, 0, mScale(0.03, 0.2, 0.05, mRotateZ(-Math.PI / 12, mTranslate(swimX * 0.45 + 1.55, 0.12, 0.2, mIdentity()))))
   },
   // bottom fin
   {
      type: 0,
      color: [0.2, 0.2, 0.8],
      mesh: new Float32Array(octahedron),
      transform: (time, swimX, swimY, swimZ) =>
         mTranslate(1.4, 0, 0, mScale(0.05, 0.3, 0.05, mRotateZ(Math.PI / 3, mTranslate(swimX * 0.45 + 1.5, -0.15 + swimY * 0.15, 0.2, mIdentity()))))
   },
   // top back fin 
   {
      type: 0,
      color: [0.2, 0.2, 0.8], 
      mesh: new Float32Array(octahedron),
      transform: (time, swimX, swimY, swimZ) =>
        mScale(0.25, 0.05, 0.2, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(0.4 + swimX * 0.45 + 0.62 + 0.95, swimY * 0.1, -0.2, mIdentity()))))
   },
   // bottom back fin
   {
      type: 0,
      color: [0.2, 0.2, 0.8], 
      mesh: new Float32Array(octahedron),
      transform: (time, swimX, swimY, swimZ) =>
         mScale(0.25, 0.05, 0.2, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(0.4 + swimX * 0.45 + 0.62 + 0.95, swimY * 0.1, -0.2, mIdentity()))))
   },
   // mouth cutout
   {
      type: 0,
      color: [0., 0., 0.], 
      mesh: new Float32Array(octahedron),
      transform: (time, swimX, swimY, swimZ) =>
        mTranslate(0, swimY * 2.5, 0, mScale(0.25, 0.05, 0.2, mRotateZ(Math.PI / 8, mTranslate(-0.52 + swimX * 0.45 + 0.65 + 0.95, -0.12, 1.0 + swimZ, mIdentity()))))
   },
   // teeth
   {
    type: 0,
    color: [1.0, 1.0, 1.0],
    mesh: new Float32Array(pyramid),
    transform: (time, swimX, swimY, swimZ) =>
        mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.02, mRotateZ(Math.PI / 1.8, mTranslate(-0.41 + swimX * 0.45 + 0.65 + 0.94, -0.048 + swimY * 0.125, 2.5 + swimZ * 0.05, mIdentity()))))
    },
    {
    type: 0,
    color: [1.0, 1.0, 1.0],
    mesh: new Float32Array(pyramid),
    transform: (time, swimX, swimY, swimZ) =>
     mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.02, mRotateZ(Math.PI / 1.8, mTranslate(-0.39 + swimX * 0.45 + 0.65 + 0.94, -0.044 + swimY * 0.125, 2.5 + swimZ * 0.05, mIdentity()))))
    },
    {
    type: 0,
    color: [1.0, 1.0, 1.0],
    mesh: new Float32Array(pyramid),
    transform: (time, swimX, swimY, swimZ) =>
        mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.02, mRotateZ(Math.PI / 1.8, mTranslate(-0.37 + swimX * 0.45 + 0.65 + 0.94, -0.04 + swimY * 0.125, 2.5 + swimZ * 0.05, mIdentity()))))
    },
    {
    type: 0,
    color: [1.0, 1.0, 1.0],
    mesh: new Float32Array(pyramid),
    transform: (time, swimX, swimY, swimZ) =>
        mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.02, mRotateZ(Math.PI / 1.9, mTranslate(-0.35 + swimX * 0.45 + 0.65 + 0.94, -0.036 + swimY * 0.125, 2.5 + swimZ * 0.05, mIdentity()))))
    },
    {
    type: 0,
    color: [1.0, 1.0, 1.0],
    mesh: new Float32Array(pyramid),
    transform: (time, swimX, swimY, swimZ) =>
        mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.02, mRotateZ(Math.PI / 1.9, mTranslate(-0.33 + swimX * 0.45 + 0.65 + 0.94, -0.032 + swimY * 0.125, 2.5 + swimZ * 0.05, mIdentity()))))
    },
    {
    type: 0,
    color: [1.0, 1.0, 1.0],
    mesh: new Float32Array(pyramid),
    transform: (time, swimX, swimY, swimZ) =>
        mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.02, mRotateZ(Math.PI / 1.9, mTranslate(-0.31 + swimX * 0.45 + 0.65 + 0.94, -0.028 + swimY * 0.125, 2.5 + swimZ * 0.05, mIdentity()))))
    },
   // Eyes 
   {
      type: 1,
      color: [0, 0, 0],
      mesh: new Float32Array(sphere(10, 10)),
      transform: (time, swimX, swimY, swimZ) =>
         mTranslate(0, swimY, swimZ, mScale(0.01, 0.01, 0.04, mTranslate(-0.38 + swimX * 0.45 + 0.65 + 0.94, 0.015 + swimY * 0.1, 2.0 + swimZ * 0.1, mIdentity())))
   },
   {
      type: 1,
      color: [1, 1, 1],
      mesh: new Float32Array(sphere(10, 10)),
      transform: (time, swimX, swimY, swimZ) =>
         mTranslate(0, swimY, swimZ, mScale(0.005, 0.005, 0.04, mTranslate(-0.385 + swimX * 0.45 + 0.65 + 0.94, 0.015 + swimY * 0.1, 2.5 + swimZ * 0.1, mIdentity())))
   }
];

let fish = [
    { 
        type: 1,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(swimX + 3.5, swimY - 15, 1.5, mScale(0.05, 0.025, 0.6, mIdentity()))
            //mTranslate(3.5, -15, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(swimX * 0.05 + 0.205, -0.375 + swimY * 0.02, 0.8, mIdentity()))))
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(swimX * 0.05 + 0.205, -0.375 + swimY * 0.02, 0.8, mIdentity()))))
    }
];

let fish2 = [
    { 
        type: 1,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(swimX + 7, swimY - 20, 1.5, mScale(0.05, 0.025, 0.6, mIdentity()))
            //mTranslate(3.5, -15, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(swimX * 0.05 + 0.38, -0.5 + swimY * 0.02, 0.8, mIdentity()))))
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(swimX * 0.05 + 0.38, -0.5 + swimY * 0.02, 0.8, mIdentity()))))
    }
];

let fish3 = [
    { 
        type: 1,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(swimX + 3.5, swimY - 25, 1.5, mScale(0.05, 0.025, 0.6, mIdentity()))
            //mTranslate(3.5, -15, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(swimX * 0.05 + 0.205, -0.625 + swimY * 0.02, 0.8, mIdentity()))))
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(swimX * 0.05 + 0.205, -0.625 + swimY * 0.02, 0.8, mIdentity()))))
    }
];

let fish4 = [
    { 
        type: 1,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(swimX, swimY - 20, 1.5, mScale(0.05, 0.025, 0.6, mIdentity()))
            //mTranslate(3.5, -15, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(swimX * 0.05 + 0.03, -0.5 + swimY * 0.02, 0.8, mIdentity()))))
    },
    {
        type: 0,
        color: [0.95, .5, 0.25],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(swimX * 0.05 + 0.03, -0.5 + swimY * 0.02, 0.8, mIdentity()))))
    }
];

let fish5 = [
    { 
        type: 1,
        color: [0.5, .03, 0.03],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(-swimX - 18, swimY + 30, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.5, 0.03, 0.03],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(-swimX * 0.05 - 0.93, 0.75 + swimY * 0.02, 0.2, mIdentity()))))
    },
    {
        type: 0,
        color: [0.5, 0.03, 0.03],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(-swimX * 0.05 - 0.93, 0.75 + swimY * 0.02, 0.2, mIdentity()))))
    }
];

let fish6 = [
    { 
        type: 1,
        color: [0.5, .03, 0.03],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(-swimX - 22, swimY + 33, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.5, 0.03, 0.03],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(-swimX * 0.05 - 1.13, 0.825 + swimY * 0.02, 0.2, mIdentity()))))
    },
    {
        type: 0,
        color: [0.5, 0.03, 0.03],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(-swimX * 0.05 - 1.13, 0.825 + swimY * 0.02, 0.2, mIdentity()))))
    }
];

let fish7 = [
    { 
        type: 1,
        color: [0.5, .03, 0.03],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(-swimX - 22, swimY + 27, swimZ, mScale(0.05, 0.025, 0.6, mIdentity()))
        
    },
    {
        type: 0,
        color: [0.5, 0.03, 0.03],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(-Math.PI / 8, mTranslate(-swimX * 0.05 - 1.13, 0.675 + swimY * 0.02, 0.2, mIdentity()))))
    },
    {
        type: 0,
        color: [0.5, 0.03, 0.03],
        mesh: new Float32Array(octahedron),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.05, 0.015, 0.05, mRotateY(Math.sin(time), mRotateZ(Math.PI / 8, mTranslate(-swimX * 0.05 - 1.13, 0.675 + swimY * 0.02, 0.2, mIdentity()))))
    }
];

let turtle = [
    { 
        type: 1,
        color: [0.54, 0.31, 0.3],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(-swimX, swimY + 16.5, swimZ, mScale(0.1, 0.03, 0.6, mIdentity()))
        
    },
    { 
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(-swimX * 0.85, swimY + 31, swimZ, mScale(0.12, 0.015, 0.6, mIdentity()))
        
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mTranslate(-swimX * 2.5 + 3, swimY + 12.5, swimZ, mScale(0.04, 0.04, 0.6, mIdentity()))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            //mTranslate(-swimX * 2.5 + 3, swimY, swimZ, mRotateY(-Math.PI / 3, mScale(0.02, 0.04, 0.6, mIdentity())))
            mScale(0.015, 0.05, 0.6, mRotateZ(-Math.PI / 4 * Math.sin(time) * 0.5, mTranslate(-swimX * 0.1 - 0.07, swimY * 0.01 + 0.46, -1, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            //mTranslate(-swimX * 2.5 + 3, swimY, swimZ, mRotateY(-Math.PI / 3, mScale(0.02, 0.04, 0.6, mIdentity())))
            mScale(0.015, 0.05, 0.6, mRotateZ(Math.PI / 4 * Math.cos(time) * 0.5, mTranslate(-swimX * 0.1 - 0.055, swimY * 0.01 + 0.46, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            mScale(0.015, 0.05, 0.6, mRotateZ(-Math.PI / 4 * Math.sin(-time) * 0.5, mTranslate(-swimX * 0.1 + 0.05, swimY * 0.01 + 0.46, -1, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
            //mTranslate(-swimX * 2.5 + 3, swimY, swimZ, mRotateY(-Math.PI / 3, mScale(0.02, 0.04, 0.6, mIdentity())))
            mScale(0.015, 0.05, 0.6, mRotateZ(Math.PI / 4 * Math.cos(time) * 0.5, mTranslate(-swimX * 0.1 + 0.06, swimY * 0.01 + 0.46, -2, mIdentity())))
    }
];

let plant = [
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.1, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.1, -0.97, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.1, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0, -0.97, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.075, 0.6, mRotateZ(-Math.PI / 3, mTranslate(0.02, -0.98, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.075, 0.6, mRotateZ(Math.PI / 3, mTranslate(-0.12, -0.98, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.1, 0.6, mRotateZ(-Math.PI / 8, mTranslate(-0.025, -0.95, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.1, 0.6, mRotateZ(Math.PI / 8, mTranslate(-0.075, -0.95, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.035, 0.22, 0.04],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) => 
        mScale(0.015, 0.1, 0.6, mRotateZ(Math.PI, mTranslate(-0.05, -0.95, -2, mIdentity())))
    },
];

let plant2 = [
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.075, 0.22, 0.6, mRotateZ(Math.PI, mTranslate(-0.7, -0.97, -2, mIdentity())))
    },
    // right
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.63, -0.97, -2.3, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.64, -0.92, -2.3, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.65, -0.87, -2.3, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.66, -0.82, -2.3, mIdentity())))
    },
    // left
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.74, -0.82, -2.3, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.75, -0.87, -2.3, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.76, -0.92, -2.3, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.77, -0.97, -2.3, mIdentity())))
    },
    
    // left middle
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.73, -0.97, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.73, -0.92, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.73, -0.87, -2.1, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.025, 0.6, mRotateZ(Math.PI / 4, mTranslate(-0.735, -0.82, -2.1, mIdentity())))
    },
    // right middle
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.675, -0.97, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.675, -0.92, -2, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.675, -0.87, -2.05, mIdentity())))
    },
    {
        type: 1,
        color: [0.0, 0.15, 0.075],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.01, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(-0.685, -0.82, -2.15, mIdentity())))
    },

];

let plant3 = [
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.04, 0.6, mRotateZ(Math.PI / 4, mTranslate(0.75, -0.97, 0, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.04, 0.6, mRotateZ(Math.PI / 2.5, mTranslate(0.74, -0.98, 0, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.04, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0.82, -0.97, 0, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.04, 0.6, mRotateZ(-Math.PI / 2.5, mTranslate(0.83, -0.98, 0, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.055, 0.6, mRotateZ(-Math.PI / 6, mTranslate(0.79, -0.97, -1, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.055, 0.6, mRotateZ(-Math.PI / 6, mTranslate(0.79, -0.97, -1, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.055, 0.6, mRotateZ(Math.PI / 6, mTranslate(0.78, -0.97, -1, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.4],
        mesh: new Float32Array(torus(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.015, 0.055, 0.6, mRotateZ(Math.PI, mTranslate(0.785, -0.97, -1.5, mIdentity())))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    },
    {
        type: 1,
        color: [0.9, 0.4, 0.8],
        mesh: new Float32Array(sphere(30, 30)),
        transform: (time, swimX, swimY, swimZ) =>
        mScale(0.02, 0.02, 0.15, mTranslate(0.78, -0.98, 1, mIdentity()))
        //mScale(0.16, 0.32, 0.16, mTranslate(0, 0, -2, mPerspective(3, mIdentity())))
    }
];

let starfish = [
    {
        type: 0,
        color: [0.9, .5, 0.9],
        mesh: new Float32Array(pyramid),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.075, 0.015, 0.05, mRotateZ(-Math.PI / 8, mTranslate(0.3,-0.95, 0.2, mIdentity())))
    },
    {
        type: 0,
        color: [0.9, .5, 0.9],
        mesh: new Float32Array(pyramid),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.075, 0.015, 0.05, mRotateZ(Math.PI / 3, mTranslate(0.3,-0.95, 0.2, mIdentity())))
    },
    {
        type: 0,
        color: [0.9, .5, 0.9],
        mesh: new Float32Array(pyramid),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.075, 0.015, 0.05, mRotateZ(2.2 * Math.PI / 3, mTranslate(0.3,-0.95, 0.2, mIdentity())))
    },
    {
        type: 0,
        color: [0.9, .5, 0.9],
        mesh: new Float32Array(pyramid),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.075, 0.015, 0.05, mRotateZ(-7 * Math.PI / 8, mTranslate(0.3,-0.95, 0.2, mIdentity())))
    },
    {
        type: 0,
        color: [0.9, .5, 0.9],
        mesh: new Float32Array(pyramid),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.075, 0.015, 0.05, mRotateZ(-Math.PI / 2, mTranslate(0.3,-0.95, 0.2, mIdentity())))
    },

];

let octopus = [
    // head
    {
        type: 1,
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.07, 0.1, 0.6, mTranslate(0.75, -0.36, 0.2, mIdentity()))
    }, 
    // rightmost arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.03, 0.6, mRotateZ(Math.PI / 3.5, mTranslate(0.81, -0.41, -0.5, mIdentity())))

    },
    // rightmost arm middle
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.03, 0.6, mRotateZ(Math.PI / 2.3, mTranslate(0.85, -0.43, 0, mIdentity())))

    },
    // rightmost arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.03, 0.6, mRotateZ(-Math.PI / 3, mTranslate(0.9, -0.42, 0, mIdentity())))

    },
    // rightmost arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(Math.PI / 12, mTranslate(0.915, -0.385, 0, mIdentity())))

    },
    // rightmost arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.015, 0.6, mRotateZ(-Math.PI / 2.5, mTranslate(0.9, -0.375, 0, mIdentity())))

    },
    // rightmost arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.01, 0.6, mRotateZ(Math.PI / 10, mTranslate(0.89, -0.39, 0, mIdentity())))

    },
    // second from right arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.05, 0.6, mRotateZ(Math.PI / 4, mTranslate(0.78, -0.41, -0.1, mIdentity())))

    },
    // second from right arm middle 
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(Math.PI / 4, mTranslate(0.82, -0.45, 0, mIdentity())))

    },
    // second from right arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(Math.PI / 3, mTranslate(0.845, -0.47, 0, mIdentity())))

    },
    // second from right arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(Math.PI / 2, mTranslate(0.875, -0.48, 0, mIdentity())))

    },
    // second from right arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.03, 0.6, mRotateZ(-Math.PI / 3, mTranslate(0.905, -0.47, 0, mIdentity())))

    },
    // second from right arm middle 5
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(Math.PI / 16, mTranslate(0.925, -0.445, 0, mIdentity())))

    },
    // second from right arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.005, 0.01, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0.915, -0.44, 0, mIdentity())))

    },
    // third from right arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(Math.PI / 8, mTranslate(0.79, -0.45, 0.15, mIdentity())))

    },
    // third from right arm middle
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(Math.PI / 5, mTranslate(0.8, -0.47, 0, mIdentity())))

    },
    // third from right arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(Math.PI / 2.4, mTranslate(0.825, -0.49, 0, mIdentity())))

    },
    // third from right arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(Math.PI / 4, mTranslate(0.85, -0.505, 0, mIdentity())))

    },
    // third from right arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(Math.PI, mTranslate(0.86, -0.52, 0, mIdentity())))

    },
    // third from right arm middle 5
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(-Math.PI/3, mTranslate(0.85, -0.54, 0, mIdentity())))

    },
    // third from right arm middle 6
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(Math.PI/6, mTranslate(0.83, -0.535, 0, mIdentity())))

    },
    // third from right arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.005, 0.01, 0.6, mRotateZ(-Math.PI/4, mTranslate(0.83, -0.52, 0, mIdentity())))

    },
    // middle right arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(Math.PI / 10, mTranslate(0.77, -0.46, 0.15, mIdentity())))

    },
    // middle right arm middle
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(Math.PI / 5, mTranslate(0.7825, -0.485, 0, mIdentity())))

    },
    // middle right arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(Math.PI / 4, mTranslate(0.8, -0.505, 0, mIdentity())))

    },
    // middle right arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.012, 0.6, mRotateZ(Math.PI, mTranslate(0.81, -0.52, 0, mIdentity())))

    },
    // middle right arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.02, 0.6, mRotateZ(-Math.PI/8, mTranslate(0.8075, -0.535, 0, mIdentity())))

    },
    // middle right arm middle 5
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.012, 0.6, mRotateZ(-Math.PI/2, mTranslate(0.79, -0.55, 0, mIdentity())))

    },
    // middle right arm middle 6
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.012, 0.6, mRotateZ(Math.PI/8, mTranslate(0.78, -0.54, 0, mIdentity())))

    },
    // middle right arm middle 7
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.012, 0.6, mRotateZ(-Math.PI/8, mTranslate(0.78, -0.53, 0, mIdentity())))

    },
    // middle right arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.005, 0.008, 0.6, mRotateZ(Math.PI/4, mTranslate(0.79, -0.525, 0, mIdentity())))

    },
     // middle left arm top
     {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(-Math.PI / 10, mTranslate(0.74, -0.46, 0.15, mIdentity())))

    },
    // middle left arm middle
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(-Math.PI / 5, mTranslate(0.7275, -0.485, 0, mIdentity())))

    },
    // middle left arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0.71, -0.505, 0, mIdentity())))

    },
    // middle left arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.012, 0.6, mRotateZ(-Math.PI, mTranslate(0.7, -0.52, 0, mIdentity())))

    },
    // middle left arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.02, 0.6, mRotateZ(Math.PI/8, mTranslate(0.7025, -0.535, 0, mIdentity())))

    },
    // middle left arm middle 5
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.012, 0.6, mRotateZ(Math.PI/2, mTranslate(0.72, -0.55, 0, mIdentity())))

    },
    // middle left arm middle 6
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.012, 0.6, mRotateZ(-Math.PI/8, mTranslate(0.73, -0.54, 0, mIdentity())))

    },
    // middle left arm middle 7
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.007, 0.012, 0.6, mRotateZ(Math.PI/8, mTranslate(0.73, -0.53, 0, mIdentity())))

    },
    // middle left arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.005, 0.008, 0.6, mRotateZ(-Math.PI/4, mTranslate(0.72, -0.525, 0, mIdentity())))

    },
    // third from left arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(-Math.PI / 8, mTranslate(0.715, -0.45, 0.15, mIdentity())))

    },
    // third from left arm middle
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(-Math.PI / 5, mTranslate(0.705, -0.47, 0, mIdentity())))

    },
    // third from left arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(-Math.PI / 2.4, mTranslate(0.68, -0.49, 0, mIdentity())))

    },
    // third from left arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0.655, -0.505, 0, mIdentity())))

    },
    // third from left arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(-Math.PI, mTranslate(0.645, -0.52, 0, mIdentity())))

    },
    // third from left arm middle 5
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(Math.PI/3, mTranslate(0.655, -0.54, 0, mIdentity())))

    },
    // third from left arm middle 6
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(-Math.PI/6, mTranslate(0.675, -0.535, 0, mIdentity())))

    },
    // third from left arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.005, 0.01, 0.6, mRotateZ(Math.PI/4, mTranslate(0.675, -0.52, 0, mIdentity())))

    },
    // second from left arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.05, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0.72, -0.41, -0.1, mIdentity())))

    },
    // second from left arm middle 
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(-Math.PI / 4, mTranslate(0.68, -0.45, 0, mIdentity())))

    },
    // second from left arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(-Math.PI / 3, mTranslate(0.655, -0.47, 0, mIdentity())))

    },
    // second from left arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.02, 0.6, mRotateZ(-Math.PI / 2, mTranslate(0.625, -0.48, 0, mIdentity())))

    },
    // second from left arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.03, 0.6, mRotateZ(Math.PI / 3, mTranslate(0.595, -0.47, 0, mIdentity())))

    },
    // second from left arm middle 5
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.015, 0.6, mRotateZ(-Math.PI / 16, mTranslate(0.575, -0.445, 0, mIdentity())))

    },
    // second from left arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.005, 0.01, 0.6, mRotateZ(Math.PI / 4, mTranslate(0.585, -0.44, 0, mIdentity())))

    },
    // leftmost arm top
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.03, 0.6, mRotateZ(-Math.PI / 3.5, mTranslate(0.69, -0.41, -0.5, mIdentity())))

    },
    // leftmost arm middle
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.03, 0.6, mRotateZ(-Math.PI / 2.3, mTranslate(0.65, -0.43, 0, mIdentity())))

    },
    // leftmost arm middle 2
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.03, 0.6, mRotateZ(Math.PI / 3, mTranslate(0.605, -0.42, 0, mIdentity())))

    },
    // leftmost arm middle 3
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.02, 0.6, mRotateZ(-Math.PI / 12, mTranslate(0.59, -0.385, 0, mIdentity())))

    },
    // leftmost arm middle 4
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.015, 0.6, mRotateZ(Math.PI / 2.5, mTranslate(0.61, -0.375, 0, mIdentity())))

    },
    // leftmost arm end
    {
        type: 1, 
        color: [0.34, .043, 0.43],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.008, 0.01, 0.6, mRotateZ(Math.PI / 10, mTranslate(0.62, -0.39, 0, mIdentity())))

    },
    {
        type: 1,
        color: [0, 0, 0],
        mesh: new Float32Array(cylinder(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.009, 0.005, 0.6, mRotateZ(-Math.PI / 2, mTranslate(0.73, -0.34, 1, mIdentity())))
    },
    {
        type: 1,
        color: [0, 0, 0],
        mesh: new Float32Array(cylinder(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.009, 0.005, 0.6, mRotateZ(-Math.PI / 2, mTranslate(0.77, -0.34, 1, mIdentity())))
    },
    {
        type: 1,
        color: [1, 1, 1],
        mesh: new Float32Array(cylinder(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.003, 0.003, 0.6, mRotateZ(-Math.PI / 2, mTranslate(0.73, -0.345, 1, mIdentity())))
    },
    {
        type: 1,
        color: [1, 1, 1],
        mesh: new Float32Array(cylinder(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.003, 0.003, 0.6, mRotateZ(-Math.PI / 2, mTranslate(0.77, -0.345, 1, mIdentity())))
    }

];

let bubbles = [
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(0.8, -0.3 + swimX * -0.05, 3.0, mIdentity()))
    },
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(0.4, 0.3 + swimX * -0.05, 3.0, mIdentity()))
    },
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(0, -0.1 + swimX * -0.05, 3.0, mIdentity()))
    },
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(-0.5, -0.8 + swimX * -0.05, 3.0, mIdentity()))
    },
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(-0.8, -0.3 + swimX * -0.05, 3.0, mIdentity()))
    },
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(-0.85, 0.3 + swimX * -0.05, 3.0, mIdentity()))
    },
    {
        type: 1, 
        color: [0.4, 0.75, 0.73],
        mesh: new Float32Array(sphere(20, 10)),
        transform: (time, swimX, swimY, swimZ) =>
            mScale(0.01, 0.01, 0.6, mTranslate(-0.35, 0.2 + swimX * -0.05, 3.0, mIdentity()))
    }
    
];

// DEFINE ALL THE OBJECT COLORS AND SHAPES

let meshData = [
   { type: 1, color: [1.,.1,.1], mesh: new Float32Array(sphere  (40, 20)) },
   { type: 1, color: [.1,1.,.1], mesh: new Float32Array(tube    (20,  1)) },
   { type: 1, color: [.1,.1,1.], mesh: new Float32Array(disk    (20,  1)) },
   { type: 1, color: [1.,1.,.1], mesh: new Float32Array(cylinder( 4,  6)) },
   { type: 1, color: [1.,.1,1.], mesh: new Float32Array(torus   (30, 30)) },
   { type: 0, color: [.1,1.,1.], mesh: new Float32Array(cube) },
   { type: 0, color: [1.,1.,1.], mesh: new Float32Array(octahedron) },
];

// VERY SIMPLE VERTEX AND FRAGMENT SHADERS

let vertexSize = 6;
let vertexShader = `
   attribute vec3 aPos, aNor;
   uniform mat4 uMatrix, uInvMatrix;
   varying vec3 vPos, vNor;
   void main() {
      vec4 pos = uMatrix * vec4(aPos, 1.0);
      vec4 nor = vec4(aNor, 0.0) * uInvMatrix;
      vPos = pos.xyz;
      vNor = nor.xyz;
      gl_Position = pos * vec4(1.,1.,-.1,1.);
   }
`;

let fragmentShader = `
   precision mediump float;
   uniform vec3 uColor;
   varying vec3 vPos, vNor;
   void main(void) {
      float c = .05 + max(0., dot(normalize(vNor), vec3(.57)));
      gl_FragColor = vec4(sqrt(c * uColor), 1.);
   }
`;

// INITIALIZE GL AND GET UNIFORM NAMES

let gl = start_gl(canvas1, meshData, vertexSize, vertexShader, fragmentShader);

let uColor     = gl.getUniformLocation(gl.program, "uColor"    );
let uInvMatrix = gl.getUniformLocation(gl.program, "uInvMatrix");
let uMatrix    = gl.getUniformLocation(gl.program, "uMatrix"   );

// THE ANIMATION LOOP
let loop = 0;
let loop2 = 0;
let loop3 = 0;
let loop4 = 0;
let loop5 = 0;

let startTime = Date.now() / 1000;
function renderFrame() {
   requestAnimationFrame(renderFrame);
   let time = Date.now() / 1000 - startTime;

   // Shark swimming: oscillate the shark's position along the y-axis

   if (loop > 14) {
      loop = 0;
   }
   loop += 0.01;
   if (loop2 > 58) {
        loop2 = -40;
    }
    loop2 += 0.01;
    if (loop3 > 22) {
        loop3 = -25;
    }
    loop3 += 0.01;
    if (loop4 > 65) {
        loop4 = -10;
    }
    loop4 += 0.01;
    if (loop5 > 70) {
        loop5 = -60;
    }
    loop5 += 0.01;
   let swimX = -0.5 * loop; // Forward swimming motion
   let swimY = 0.1 * Math.sin(time * 2); // Vertical oscillation
   let swimZ = 0.01 * time; // Forward swimming motion
   let fishX = -0.5 * loop2;
   let fish2X = -0.5 * loop4;
   let turtleX = -0.5 * loop3;
   let bubbleX = -0.5 * loop5;


   for (let part of sharkParts) {
      let m = part.transform(time, swimX, swimY, swimZ); 

      gl.uniform3fv(uColor, part.color);
      gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
      gl.uniformMatrix4fv(uMatrix, false, m);

      let mesh = part.mesh;
      gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
      gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
   }

   for (let part of fish) {
    let m = part.transform(time, fishX, swimY, swimZ); 

    gl.uniform3fv(uColor, part.color);
    gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
    gl.uniformMatrix4fv(uMatrix, false, m);

    let mesh = part.mesh;
    gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
    gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
   }

   for (let part of fish2) {
    let m = part.transform(time, fishX, swimY, swimZ); 

    gl.uniform3fv(uColor, part.color);
    gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
    gl.uniformMatrix4fv(uMatrix, false, m);

    let mesh = part.mesh;
    gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
    gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
   }

   for (let part of fish3) {
    let m = part.transform(time, fishX, swimY, swimZ); 

    gl.uniform3fv(uColor, part.color);
    gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
    gl.uniformMatrix4fv(uMatrix, false, m);

    let mesh = part.mesh;
    gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
    gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
   }

   for (let part of fish4) {
    let m = part.transform(time, fishX, swimY, swimZ); 

    gl.uniform3fv(uColor, part.color);
    gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
    gl.uniformMatrix4fv(uMatrix, false, m);

    let mesh = part.mesh;
    gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
    gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of fish5) {
        let m = part.transform(time, fish2X, swimY, swimZ);

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of fish6) {
        let m = part.transform(time, fish2X, swimY, swimZ);

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of fish7) {
        let m = part.transform(time, fish2X, swimY, swimZ);

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of turtle) {
        let m = part.transform(time, turtleX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of plant) {
        let m = part.transform(time, swimX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of plant2) {
        let m = part.transform(time, swimX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of plant3) {
        let m = part.transform(time, swimX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        console.log(mesh);
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of starfish) {
        let m = part.transform(time, swimX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of octopus) {
        let m = part.transform(time, swimX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }

    for (let part of bubbles) {
        let m = part.transform(time, bubbleX, swimY, swimZ); 

        gl.uniform3fv(uColor, part.color);
        gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m));
        gl.uniformMatrix4fv(uMatrix, false, m);

        let mesh = part.mesh;
        gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
        gl.drawArrays(part.type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
    }
}

requestAnimationFrame(renderFrame);

</script>


